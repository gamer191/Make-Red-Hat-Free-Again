diff --git a/usr/share/rear/layout/save/GNU/Linux/200_partition_layout.sh b/usr/share/rear/layout/save/GNU/Linux/200_partition_layout.sh
index da6ce64c4..ab14ec83f 100644
--- a/usr/share/rear/layout/save/GNU/Linux/200_partition_layout.sh
+++ b/usr/share/rear/layout/save/GNU/Linux/200_partition_layout.sh
@@ -395,6 +395,10 @@ Log "Saving disk partitions."
             elif [[ ! ($blockd = *rpmb || $blockd = *[0-9]boot[0-9]) ]]; then # Silently skip Replay Protected Memory Blocks and others  
                 devname=$(get_device_name $disk)
                 devsize=$(get_disk_size ${disk#/sys/block/})
+                if ! validation_error=$(is_disk_valid $devname) ; then
+                    LogPrintError "Ignoring $blockd: $validation_error"
+                    continue
+                fi
                 disktype=$(parted -s $devname print | grep -E "Partition Table|Disk label" | cut -d ":" -f "2" | tr -d " ")
                 if [ "$disktype" != "dasd" ]; then
                     echo "# Disk $devname"
diff --git a/usr/share/rear/lib/layout-functions.sh b/usr/share/rear/lib/layout-functions.sh
index f5fc7538e..90b16cb20 100644
--- a/usr/share/rear/lib/layout-functions.sh
+++ b/usr/share/rear/lib/layout-functions.sh
@@ -834,6 +834,40 @@ is_disk_a_pv() {
     return 1
 }
 
+# Check whether disk is suitable for being added to layout
+# Can be used to skip obviously unsuitable/broken devices
+# (missing device node, zero size, device can't be opened).
+# Should not be used to skip potential mapping targets before layout restoration
+# - an invalid disk may become valid later, for example if it is a DASD that needs
+# low-level formatting (see 090_include_dasd_code.sh and 360_generate_dasd_format_code.sh),
+# unformatted DASDs show zero size.
+# Returns 0 if the device is ok
+# Returns nonzero code if it should be skipped, and a text describing the error
+# (without the device name) on stdout
+# usage example:
+# local err
+# if ! err=$(is_disk_valid /dev/sda); then
+
+function is_disk_valid {
+    local disk="$1"
+    local size
+
+    if ! test -b "$disk" ; then
+        echo "$disk is not a block device"
+        return 1
+    fi
+    # capture stdout in a variable and redirect stderr to stdout - the error message
+    # will be our output
+    if { size=$(blockdev --getsize64 "$disk") ; } 2>&1 ; then
+        if ! test "$size" -gt 0 2>/dev/null ; then
+            echo "$disk has invalid size $size"
+            return 1
+        fi
+    else
+        return 1
+    fi
+}
+
 function is_multipath_path {
     # Return 'false' if there is no device as argument:
     test "$1" || return 1
