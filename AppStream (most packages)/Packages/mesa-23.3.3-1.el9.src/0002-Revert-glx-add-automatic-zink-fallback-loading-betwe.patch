From 9b9d225931b69532aa1b43abdaf29c826bc47b26 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Jos=C3=A9=20Exp=C3=B3sito?= <jexposit@redhat.com>
Date: Wed, 17 Jan 2024 13:21:08 +0100
Subject: [PATCH 2/2] Revert "glx: add automatic zink fallback loading between
 hw and sw drivers"

This reverts commit 7d9ea77b4598e23d4415b529924f1cbdca6e33bd.
---
 src/glx/glxext.c | 33 ++++++++-------------------------
 1 file changed, 8 insertions(+), 25 deletions(-)

diff --git a/src/glx/glxext.c b/src/glx/glxext.c
index 39d5f08bdcf..5036fd137c1 100644
--- a/src/glx/glxext.c
+++ b/src/glx/glxext.c
@@ -763,11 +763,10 @@ glx_screen_cleanup(struct glx_screen *psc)
 ** If that works then fetch the per screen configs data.
 */
 static Bool
-AllocAndFetchScreenConfigs(Display * dpy, struct glx_display * priv, Bool zink)
+AllocAndFetchScreenConfigs(Display * dpy, struct glx_display * priv)
 {
    struct glx_screen *psc;
    GLint i, screens;
-   unsigned screen_count = 0;
 
    /*
     ** First allocate memory for the array of per screen configs.
@@ -804,21 +803,17 @@ AllocAndFetchScreenConfigs(Display * dpy, struct glx_display * priv, Bool zink)
       if (psc == NULL)
          psc = applegl_create_screen(i, priv);
 #else
-      if (psc == NULL && !zink)
+      if (psc == NULL)
       {
          psc = indirect_create_screen(i, priv);
          indirect = true;
       }
 #endif
       priv->screens[i] = psc;
-      if (psc)
-         screen_count++;
 
       if(indirect) /* Load extensions required only for indirect glx */
          glxSendClientInfo(priv, i);
    }
-   if (zink && !screen_count)
-      return GL_FALSE;
    SyncHandle();
    return GL_TRUE;
 }
@@ -880,9 +875,9 @@ __glXInitialize(Display * dpy)
 #if defined(GLX_DIRECT_RENDERING) && !defined(GLX_USE_APPLEGL)
    Bool glx_direct = !debug_get_bool_option("LIBGL_ALWAYS_INDIRECT", false);
    Bool glx_accel = !debug_get_bool_option("LIBGL_ALWAYS_SOFTWARE", false);
+   Bool zink;
    const char *env = getenv("MESA_LOADER_DRIVER_OVERRIDE");
-   Bool zink = env && !strcmp(env, "zink");
-   Bool try_zink = False;
+   zink = env && !strcmp(env, "zink");
 
    dpyPriv->drawHash = __glxHashCreate();
 
@@ -904,13 +899,10 @@ __glXInitialize(Display * dpy)
 #endif /* HAVE_DRI3 */
       if (!debug_get_bool_option("LIBGL_DRI2_DISABLE", false))
          dpyPriv->dri2Display = dri2CreateDisplay(dpy);
-      if (!dpyPriv->dri3Display && !dpyPriv->dri2Display)
-         try_zink = !debug_get_bool_option("LIBGL_KOPPER_DISABLE", false) &&
-                    !getenv("GALLIUM_DRIVER");
    }
 #endif /* GLX_USE_DRM */
    if (glx_direct)
-      dpyPriv->driswDisplay = driswCreateDisplay(dpy, zink | try_zink);
+      dpyPriv->driswDisplay = driswCreateDisplay(dpy, zink);
 
 #ifdef GLX_USE_WINDOWSGL
    if (glx_direct && glx_accel)
@@ -925,18 +917,9 @@ __glXInitialize(Display * dpy)
    }
 #endif
 
-   if (!AllocAndFetchScreenConfigs(dpy, dpyPriv, zink | try_zink)) {
-      Bool fail = True;
-      if (try_zink) {
-         free(dpyPriv->screens);
-         dpyPriv->driswDisplay->destroyDisplay(dpyPriv->driswDisplay);
-         dpyPriv->driswDisplay = driswCreateDisplay(dpy, false);
-         fail = !AllocAndFetchScreenConfigs(dpy, dpyPriv, False);
-      }
-      if (fail) {
-         free(dpyPriv);
-         return NULL;
-      }
+   if (!AllocAndFetchScreenConfigs(dpy, dpyPriv)) {
+      free(dpyPriv);
+      return NULL;
    }
 
    glxSendClientInfo(dpyPriv, -1);
-- 
2.43.0

