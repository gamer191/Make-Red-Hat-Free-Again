From a99d9f2afee17688ec07e2ea0b130341a0cabce2 Mon Sep 17 00:00:00 2001
From: "Richard W.M. Jones" <rjones@redhat.com>
Date: Tue, 16 Jan 2024 10:27:30 +0000
Subject: [PATCH] input/nbdkit_ssh: Make password parameter optional

Instead of storing an explicit NoPassword case, make the password
parameter optional and encode NoPassword as None.  This is simple
refactoring.
---
 input/input_vmx.ml              |  8 ++++----
 input/input_xen_ssh.ml          |  6 +++---
 input/nbdkit_ssh.ml             | 13 ++++++-------
 input/nbdkit_ssh.mli            |  9 ++++-----
 input/parse_domain_from_vmx.ml  |  6 +++---
 input/parse_domain_from_vmx.mli |  8 ++++----
 input/ssh.ml                    | 12 ++++++------
 input/ssh.mli                   |  8 ++++----
 8 files changed, 34 insertions(+), 36 deletions(-)

diff --git a/input/input_vmx.ml b/input/input_vmx.ml
index b3426fa2..f81a9674 100644
--- a/input/input_vmx.ml
+++ b/input/input_vmx.ml
@@ -47,8 +47,8 @@ module VMX = struct
       | [arg] ->
          let input_password =
            match options.input_password with
-           | None -> Nbdkit_ssh.NoPassword
-           | Some ip -> Nbdkit_ssh.PasswordFile ip in
+           | None -> None
+           | Some ip -> Some (Nbdkit_ssh.PasswordFile ip) in
          let input_transport =
            match options.input_transport with
            | None -> None
@@ -102,7 +102,7 @@ module VMX = struct
             let user = uri.Xml.uri_user in
 
             (* RHBZ#1774386 *)
-            if not (Ssh.remote_file_exists ~password ?port ~server ?user
+            if not (Ssh.remote_file_exists ?password ?port ~server ?user
                       flat_vmdk) then
               error (f_"This transport does not support guests with snapshots. \
                         Either collapse the snapshots for this guest and try \
@@ -112,7 +112,7 @@ module VMX = struct
 
             let cor = dir // "convert" in
             let bandwidth = options.bandwidth in
-            let nbdkit = Nbdkit_ssh.create_ssh ?bandwidth ~cor ~password
+            let nbdkit = Nbdkit_ssh.create_ssh ?bandwidth ~cor ?password
                            ~server ?port ?user flat_vmdk in
             let _, pid = Nbdkit.run_unix socket nbdkit in
             On_exit.kill pid
diff --git a/input/input_xen_ssh.ml b/input/input_xen_ssh.ml
index b583bd55..c4235a4b 100644
--- a/input/input_xen_ssh.ml
+++ b/input/input_xen_ssh.ml
@@ -96,8 +96,8 @@ module XenSSH = struct
 
     let password =
       match options.input_password with
-      | None -> Nbdkit_ssh.NoPassword
-      | Some ip -> Nbdkit_ssh.PasswordFile ip in
+      | None -> None
+      | Some ip -> Some (Nbdkit_ssh.PasswordFile ip) in
 
     (* Create an nbdkit instance for each disk. *)
     List.iteri (
@@ -122,7 +122,7 @@ module XenSSH = struct
         | LocalFile path ->
            let cor = dir // "convert" in
            let bandwidth = options.bandwidth in
-           let nbdkit = Nbdkit_ssh.create_ssh ?bandwidth ~cor ~password
+           let nbdkit = Nbdkit_ssh.create_ssh ?bandwidth ~cor ?password
                           ?port ~server ?user path in
            let _, pid = Nbdkit.run_unix socket nbdkit in
            On_exit.kill pid
diff --git a/input/nbdkit_ssh.ml b/input/nbdkit_ssh.ml
index 3b72d3ad..bc96df13 100644
--- a/input/nbdkit_ssh.ml
+++ b/input/nbdkit_ssh.ml
@@ -28,9 +28,8 @@ open Utils
 let nbdkit_min_version = (1, 12, 0)
 
 type password =
-| NoPassword                    (* no password option at all *)
-| AskForPassword                (* password=- *)
-| PasswordFile of string        (* password=+file *)
+  | AskForPassword
+  | PasswordFile of string
 
 let error_unless_nbdkit_version_ge config min_version =
   let version = Nbdkit.version config in
@@ -45,7 +44,7 @@ let error_unless_nbdkit_min_version config =
 
 (* Create an nbdkit module specialized for reading from SSH sources. *)
 let create_ssh ?bandwidth ?cor ?(retry=true)
-      ~password ?port ~server ?user path =
+      ?password ?port ~server ?user path =
   if not (Nbdkit.is_installed ()) then
     error (f_"nbdkit is not installed or not working");
 
@@ -108,8 +107,8 @@ let create_ssh ?bandwidth ?cor ?(retry=true)
 
   (* Handle the password parameter specially. *)
   (match password with
-   | NoPassword -> ()
-   | AskForPassword ->
+   | None -> ()
+   | Some AskForPassword ->
       (* Because we will start nbdkit in the background and then wait
        * for 30 seconds for it to start up, we cannot use the
        * password=- feature of nbdkit to read the password
@@ -130,7 +129,7 @@ let create_ssh ?bandwidth ?cor ?(retry=true)
       On_exit.unlink password_file;
       with_open_out password_file (fun chan -> output_string chan password);
       Nbdkit.add_arg cmd "password" ("+" ^ password_file)
-   | PasswordFile password_file ->
+   | Some (PasswordFile password_file) ->
       Nbdkit.add_arg cmd "password" ("+" ^ password_file)
   );
 
diff --git a/input/nbdkit_ssh.mli b/input/nbdkit_ssh.mli
index daa20bb2..8ea8dea4 100644
--- a/input/nbdkit_ssh.mli
+++ b/input/nbdkit_ssh.mli
@@ -18,15 +18,14 @@
 
 (** nbdkit when used as a source. *)
 
-type password =
-| NoPassword
-| AskForPassword
-| PasswordFile of string
+type password =                 (** Use [None] for no password *)
+  | AskForPassword              (** [password=-] *)
+  | PasswordFile of string      (** [password=+file] *)
 
 val create_ssh : ?bandwidth:Types.bandwidth ->
                  ?cor:string ->
                  ?retry:bool ->
-                 password:password ->
+                 ?password:password ->
                  ?port:string ->
                  server:string ->
                  ?user:string ->
diff --git a/input/parse_domain_from_vmx.ml b/input/parse_domain_from_vmx.ml
index 99c86b1a..eeac6597 100644
--- a/input/parse_domain_from_vmx.ml
+++ b/input/parse_domain_from_vmx.ml
@@ -29,8 +29,8 @@ open Utils
 open Name_from_disk
 
 type vmx_source =
-  | File of string                       (* local file or NFS *)
-  | SSH of Nbdkit_ssh.password * Xml.uri (* SSH URI *)
+  | File of string              (* local file or NFS *)
+  | SSH of Nbdkit_ssh.password option * Xml.uri (* SSH URI *)
 
 (* The single filename on the command line is intepreted either as
  * a local file or a remote SSH URI (only if ‘-it ssh’).
@@ -349,7 +349,7 @@ let parse_domain_from_vmx vmx_source =
          | None -> assert false (* checked by vmx_source_of_arg *)
          | Some path -> path in
        let filename = tmpdir // "source.vmx" in
-       Ssh.download_file ~password ?port ~server ?user path filename;
+       Ssh.download_file ?password ?port ~server ?user path filename;
        Parse_vmx.parse_file filename in
 
   let name =
diff --git a/input/parse_domain_from_vmx.mli b/input/parse_domain_from_vmx.mli
index 208797a7..e26a1035 100644
--- a/input/parse_domain_from_vmx.mli
+++ b/input/parse_domain_from_vmx.mli
@@ -17,9 +17,9 @@
  *)
 
 type vmx_source =
-  | File of string                       (** local file or NFS *)
-  | SSH of Nbdkit_ssh.password * Xml.uri (** SSH URI *)
+  | File of string              (** local file or NFS *)
+  | SSH of Nbdkit_ssh.password option * Xml.uri (** SSH URI *)
 
-val vmx_source_of_arg : Nbdkit_ssh.password -> [`SSH] option -> string ->
-                        vmx_source
+val vmx_source_of_arg : Nbdkit_ssh.password option -> [`SSH] option ->
+                        string -> vmx_source
 val parse_domain_from_vmx : vmx_source -> Types.source * string list
diff --git a/input/ssh.ml b/input/ssh.ml
index 71ebbf2a..10c61bbf 100644
--- a/input/ssh.ml
+++ b/input/ssh.ml
@@ -23,7 +23,7 @@ open Common_gettext.Gettext
 
 open Printf
 
-let start_nbdkit ~password ?port ~server ?user path =
+let start_nbdkit ?password ?port ~server ?user path =
   (* Create a random location for the socket used to talk to nbdkit. *)
   let sockdir = Mkdtemp.temp_dir "v2vssh." in
   On_exit.rm_rf sockdir;
@@ -35,7 +35,7 @@ let start_nbdkit ~password ?port ~server ?user path =
    * the VMX file is large, so using this filter isn't necessary.
    *)
   let nbdkit =
-    Nbdkit_ssh.create_ssh ~retry:false ~password ~server ?port ?user path in
+    Nbdkit_ssh.create_ssh ~retry:false ?password ~server ?port ?user path in
   Nbdkit.set_readonly nbdkit true;
   let _, pid = Nbdkit.run_unix socket nbdkit in
   On_exit.kill pid;
@@ -44,8 +44,8 @@ let start_nbdkit ~password ?port ~server ?user path =
   "nbd+unix://?socket=" ^ socket
 
 (* Download a remote file into a local file. *)
-let download_file ~password ?port ~server ?user path output =
-  let uri = start_nbdkit ~password ?port ~server ?user path in
+let download_file ?password ?port ~server ?user path output =
+  let uri = start_nbdkit ?password ?port ~server ?user path in
 
   let cmd = [ "nbdcopy"; uri; output ] in
   if run_command cmd <> 0 then
@@ -53,8 +53,8 @@ let download_file ~password ?port ~server ?user path output =
               see earlier error messages")
 
 (* Test if [path] exists on the remote server. *)
-let remote_file_exists ~password ?port ~server ?user path =
-  let uri = start_nbdkit ~password ?port ~server ?user path in
+let remote_file_exists ?password ?port ~server ?user path =
+  let uri = start_nbdkit ?password ?port ~server ?user path in
 
   (* Testing for remote size using nbdinfo should be sufficient to
    * prove the remote file exists.
diff --git a/input/ssh.mli b/input/ssh.mli
index 40843024..6d9f1370 100644
--- a/input/ssh.mli
+++ b/input/ssh.mli
@@ -21,15 +21,15 @@
     Internally this uses nbdkit-ssh-plugin (which uses sftp) as
     that is much more predictable than running external ssh / scp. *)
 
-(** [remote_file_exists password ?port server ?user path]
+(** [remote_file_exists ?password ?port server ?user path]
     checks that [path] exists on the remote server. *)
-val remote_file_exists : password:Nbdkit_ssh.password ->
+val remote_file_exists : ?password:Nbdkit_ssh.password ->
                          ?port:string -> server:string -> ?user:string ->
                          string -> bool
 
-(** [download_file password ?port server ?user path output]
+(** [download_file ?password ?port server ?user path output]
     downloads the single remote file at [path] to
     the local file called [output]. *)
-val download_file : password:Nbdkit_ssh.password ->
+val download_file : ?password:Nbdkit_ssh.password ->
                     ?port:string -> server:string -> ?user:string -> string ->
                     string -> unit
