From 4dde420fc3e24077ab926f79674eaae1b71de10b Mon Sep 17 00:00:00 2001
From: Pawel Piatkowski <pawel.piatkowski@intel.com>
Date: Thu, 19 Oct 2023 16:35:24 +0200
Subject: [PATCH 164/165] mdadm: remove container_enough logic

Arrays without enough disk count will be assembled but not
started.
Now RAIDs will be assembled always (even if they are failed).
RAID devices in all states will be assembled and exposed
to mdstat.
This change affects only IMSM (for ddf it wasn't used,
container_enough was set to true always).
Removed this logic from incremental_container as well with
runstop checking because runstop condition is being verified
in assemble_container_content function.

Signed-off-by: Pawel Piatkowski <pawel.piatkowski@intel.com>
Signed-off-by: Jes Sorensen <jes@trained-monkey.org>
---
 Incremental.c | 11 -----------
 mdadm.h       |  3 ---
 super-ddf.c   |  1 -
 super-intel.c | 32 +-------------------------------
 4 files changed, 1 insertion(+), 46 deletions(-)

diff --git a/Incremental.c b/Incremental.c
index 05b33c45..3551c65b 100644
--- a/Incremental.c
+++ b/Incremental.c
@@ -1467,17 +1467,6 @@ static int Incremental_container(struct supertype *st, char *devname,
 
 	st->ss->getinfo_super(st, &info, NULL);
 
-	if ((c->runstop > 0 && info.container_enough >= 0) ||
-	    info.container_enough > 0)
-		/* pass */;
-	else {
-		if (c->export) {
-			printf("MD_STARTED=no\n");
-		} else if (c->verbose)
-			pr_err("not enough devices to start the container\n");
-		return 0;
-	}
-
 	match = conf_match(st, &info, devname, c->verbose, &rv);
 	if (match == NULL && rv == 2)
 		return rv;
diff --git a/mdadm.h b/mdadm.h
index 9effb941..b48e6f86 100644
--- a/mdadm.h
+++ b/mdadm.h
@@ -377,9 +377,6 @@ struct mdinfo {
 	int container_member; /* for assembling external-metatdata arrays
 			       * This is to be used internally by metadata
 			       * handler only */
-	int container_enough; /* flag external handlers can set to
-			       * indicate that subarrays have not enough (-1),
-			       * enough to start (0), or all expected disks (1) */
 	char		sys_name[32];
 	struct mdinfo *devs;
 	struct mdinfo *next;
diff --git a/super-ddf.c b/super-ddf.c
index 7571e3b7..a87e3169 100644
--- a/super-ddf.c
+++ b/super-ddf.c
@@ -1975,7 +1975,6 @@ static void getinfo_super_ddf(struct supertype *st, struct mdinfo *info, char *m
 	info->array.ctime	  = DECADE + __be32_to_cpu(*cptr);
 
 	info->array.chunk_size	  = 0;
-	info->container_enough	  = 1;
 
 	info->disk.major	  = 0;
 	info->disk.minor	  = 0;
diff --git a/super-intel.c b/super-intel.c
index 05d3b056..6bdd5c4c 100644
--- a/super-intel.c
+++ b/super-intel.c
@@ -3806,7 +3806,6 @@ static void getinfo_super_imsm(struct supertype *st, struct mdinfo *info, char *
 	struct intel_super *super = st->sb;
 	struct imsm_disk *disk;
 	int map_disks = info->array.raid_disks;
-	int max_enough = -1;
 	int i;
 	struct imsm_super *mpb;
 
@@ -3848,12 +3847,9 @@ static void getinfo_super_imsm(struct supertype *st, struct mdinfo *info, char *
 
 	for (i = 0; i < mpb->num_raid_devs; i++) {
 		struct imsm_dev *dev = get_imsm_dev(super, i);
-		int failed, enough, j, missing = 0;
+		int j = 0;
 		struct imsm_map *map;
-		__u8 state;
 
-		failed = imsm_count_failed(super, dev, MAP_0);
-		state = imsm_check_degraded(super, dev, failed, MAP_0);
 		map = get_imsm_map(dev, MAP_0);
 
 		/* any newly missing disks?
@@ -3868,36 +3864,10 @@ static void getinfo_super_imsm(struct supertype *st, struct mdinfo *info, char *
 
 			if (!(ord & IMSM_ORD_REBUILD) &&
 			    get_imsm_missing(super, idx)) {
-				missing = 1;
 				break;
 			}
 		}
-
-		if (state == IMSM_T_STATE_FAILED)
-			enough = -1;
-		else if (state == IMSM_T_STATE_DEGRADED &&
-			 (state != map->map_state || missing))
-			enough = 0;
-		else /* we're normal, or already degraded */
-			enough = 1;
-		if (is_gen_migration(dev) && missing) {
-			/* during general migration we need all disks
-			 * that process is running on.
-			 * No new missing disk is allowed.
-			 */
-			max_enough = -1;
-			enough = -1;
-			/* no more checks necessary
-			 */
-			break;
-		}
-		/* in the missing/failed disk case check to see
-		 * if at least one array is runnable
-		 */
-		max_enough = max(max_enough, enough);
 	}
-	dprintf("enough: %d\n", max_enough);
-	info->container_enough = max_enough;
 
 	if (super->disks) {
 		__u32 reserved = imsm_reserved_sectors(super, super->disks);
-- 
2.40.1

