From 7ef7c73bc3a271e3e5ccb8b1525c6e9152b99c9a Mon Sep 17 00:00:00 2001
Message-ID: <7ef7c73bc3a271e3e5ccb8b1525c6e9152b99c9a.1709652372.git.aclaudi@redhat.com>
In-Reply-To: <d60a7ac3c0f6aa2a933f48a69ab31e3637f6906c.1709652372.git.aclaudi@redhat.com>
References: <d60a7ac3c0f6aa2a933f48a69ab31e3637f6906c.1709652372.git.aclaudi@redhat.com>
From: Andrea Claudi <aclaudi@redhat.com>
Date: Mon, 4 Mar 2024 23:37:51 +0100
Subject: [PATCH] iplink: add gso and gro max_size attributes for ipv4

JIRA: https://issues.redhat.com/browse/RHEL-579
Upstream Status: iproute2.git commit 1dafe448c7a2f2be5dfddd8da250980708a48c41

commit 1dafe448c7a2f2be5dfddd8da250980708a48c41
Author: Xin Long <lucien.xin@gmail.com>
Date:   Thu Feb 9 18:44:24 2023 -0500

    iplink: add gso and gro max_size attributes for ipv4

    This patch adds two attributes gso/gro_ipv4_max_size in iplink for the
    user space support of the BIG TCP for IPv4:

      https://lore.kernel.org/netdev/de811bf3-e2d8-f727-72bc-c8a754a9d929@tessares.net/T/

    Note that after this kernel patchset, "gso/gro_max_size" are used for IPv6
    packets while "gso/gro_ipv4_max_size" are for IPv4 patckets. To not break
    these old applications using "gso/gro_ipv4_max_size" for IPv4 GSO packets,
    the new size will also be set on "gso/gro_ipv4_max_size" in kernel when
    "gso/gro_max_size" changes to a value <= 65536.

    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: David Ahern <dsahern@kernel.org>

Signed-off-by: Andrea Claudi <aclaudi@redhat.com>
---
 ip/ipaddress.c        | 12 ++++++++++++
 ip/iplink.c           | 22 ++++++++++++++++++++--
 man/man8/ip-link.8.in | 30 +++++++++++++++++++++++++++---
 3 files changed, 59 insertions(+), 5 deletions(-)

diff --git a/ip/ipaddress.c b/ip/ipaddress.c
index c7553bcd..9ba81438 100644
--- a/ip/ipaddress.c
+++ b/ip/ipaddress.c
@@ -1264,6 +1264,18 @@ int print_linkinfo(struct nlmsghdr *n, void *arg)
 				   "gro_max_size %u ",
 				   rta_getattr_u32(tb[IFLA_GRO_MAX_SIZE]));
 
+		if (tb[IFLA_GSO_IPV4_MAX_SIZE])
+			print_uint(PRINT_ANY,
+				   "gso_ipv4_max_size",
+				   "gso_ipv4_max_size %u ",
+				   rta_getattr_u32(tb[IFLA_GSO_IPV4_MAX_SIZE]));
+
+		if (tb[IFLA_GRO_IPV4_MAX_SIZE])
+			print_uint(PRINT_ANY,
+				   "gro_ipv4_max_size",
+				   "gro_ipv4_max_size %u ",
+				   rta_getattr_u32(tb[IFLA_GRO_IPV4_MAX_SIZE]));
+
 		if (tb[IFLA_PHYS_PORT_NAME])
 			print_string(PRINT_ANY,
 				     "phys_port_name",
diff --git a/ip/iplink.c b/ip/iplink.c
index 4ec9e370..a8da52f9 100644
--- a/ip/iplink.c
+++ b/ip/iplink.c
@@ -114,8 +114,8 @@ void iplink_usage(void)
 		"		[ addrgenmode { eui64 | none | stable_secret | random } ]\n"
 		"		[ protodown { on | off } ]\n"
 		"		[ protodown_reason PREASON { on | off } ]\n"
-		"		[ gso_max_size BYTES ] | [ gso_max_segs PACKETS ]\n"
-		"		[ gro_max_size BYTES ]\n"
+		"		[ gso_max_size BYTES ] [ gso_ipv4_max_size BYTES ] [ gso_max_segs PACKETS ]\n"
+		"		[ gro_max_size BYTES ] [ gro_ipv4_max_size BYTES ]\n"
 		"\n"
 		"	ip link show [ DEVICE | group GROUP ] [up] [master DEV] [vrf NAME] [type TYPE]\n"
 		"		[nomaster]\n"
@@ -948,6 +948,24 @@ int iplink_parse(int argc, char **argv, struct iplink_req *req, char **type)
 				       *argv);
 			addattr32(&req->n, sizeof(*req),
 				  IFLA_GRO_MAX_SIZE, max_size);
+		} else if (strcmp(*argv, "gso_ipv4_max_size") == 0) {
+			unsigned int max_size;
+
+			NEXT_ARG();
+			if (get_unsigned(&max_size, *argv, 0))
+				invarg("Invalid \"gso_ipv4_max_size\" value\n",
+				       *argv);
+			addattr32(&req->n, sizeof(*req),
+				  IFLA_GSO_IPV4_MAX_SIZE, max_size);
+		}  else if (strcmp(*argv, "gro_ipv4_max_size") == 0) {
+			unsigned int max_size;
+
+			NEXT_ARG();
+			if (get_unsigned(&max_size, *argv, 0))
+				invarg("Invalid \"gro_ipv4_max_size\" value\n",
+				       *argv);
+			addattr32(&req->n, sizeof(*req),
+				  IFLA_GRO_IPV4_MAX_SIZE, max_size);
 		} else if (strcmp(*argv, "parentdev") == 0) {
 			NEXT_ARG();
 			addattr_l(&req->n, sizeof(*req), IFLA_PARENT_DEV_NAME,
diff --git a/man/man8/ip-link.8.in b/man/man8/ip-link.8.in
index 62aebabd..bec1b78b 100644
--- a/man/man8/ip-link.8.in
+++ b/man/man8/ip-link.8.in
@@ -38,11 +38,16 @@ ip-link \- network device configuration
 .br
 .RB "[ " gso_max_size
 .IR BYTES " ]"
+.RB "[ " gso_ipv4_max_size
+.IR BYTES " ]"
 .RB "[ " gso_max_segs
 .IR SEGMENTS " ]"
 .br
 .RB "[ " gro_max_size
 .IR BYTES " ]"
+.RB "[ " gro_ipv4_max_size
+.IR BYTES " ]"
+.br
 .RB "[ " netns " {"
 .IR PID " | " NETNSNAME " } ]"
 .br
@@ -90,10 +95,15 @@ ip-link \- network device configuration
 .br
 .RB "[ " gso_max_size
 .IR BYTES " ]"
+.RB "[ " gso_ipv4_max_size
+.IR BYTES " ]"
 .RB "[ " gso_max_segs
 .IR SEGMENTS " ]"
+.br
 .RB "[ " gro_max_size
 .IR BYTES " ]"
+.RB "[ " gro_ipv4_max_size
+.IR BYTES " ]"
 .br
 .RB "[ " name
 .IR NEWNAME " ]"
@@ -423,7 +433,14 @@ specifies the number of receive queues for new device.
 .TP
 .BI gso_max_size " BYTES "
 specifies the recommended maximum size of a Generic Segment Offload
-packet the new device should accept.
+packet the new device should accept. This is also used to enable BIG
+TCP for IPv6 on this device when the size is greater than 65536.
+
+.TP
+.BI gso_ipv4_max_size " BYTES "
+specifies the recommended maximum size of a IPv4 Generic Segment Offload
+packet the new device should accept. This is especially used to enable
+BIG TCP for IPv4 on this device by setting to a size greater than 65536.
 
 .TP
 .BI gso_max_segs " SEGMENTS "
@@ -432,8 +449,15 @@ segments the new device should accept.
 
 .TP
 .BI gro_max_size " BYTES "
-specifies the maximum size of a packet built by GRO stack
-on this device.
+specifies the maximum size of a packet built by GRO stack on this
+device. This is also used for BIG TCP to allow the size of a
+merged IPv6 GSO packet on this device greater than 65536.
+
+.TP
+.BI gro_ipv4_max_size " BYTES "
+specifies the maximum size of a IPv4 packet built by GRO stack on this
+device. This is especially used for BIG TCP to allow the size of a
+merged IPv4 GSO packet on this device greater than 65536.
 
 .TP
 .BI index " IDX "
-- 
2.44.0

